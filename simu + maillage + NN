# -*- coding: utf-8 -*-
"""
Created on Sun Oct  5 14:05:25 2025

@author: Didier
"""

import numpy as np
import torch
from torch import nn
from torch.utils.data import Dataset
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation


# --- ParamÃ¨tres de la rue ---
L = 100.0   # longueur (m)
W = 7       # largeur (m)

# --- ParamÃ¨tres des piÃ©tons ---
N = 100
v_desired = 1.3
relax_time = 0.5
A = 2.0
B = 0.5
wall_repulsion = 1
dt = 0.5
steps = 90

# --- Initialisation ---
positions = np.zeros((N, 2))
positions[:, 0] = np.random.uniform(0, L/4, N)
positions[:, 1] = np.random.uniform(0, W, N)
velocities = np.zeros((N, 2))

# Tableau pour stocker les positions et vitesses
All_positions = np.zeros((steps, N, 2))
All_velocities = np.zeros((steps, N, 2))

# --- Force sociale ---
def social_forces(positions, velocities):
    Nb = positions.shape[0]
    forces = np.zeros_like(positions)

    v0 = np.zeros_like(velocities)
    v0[:, 0] = v_desired
    forces += (v0 - velocities) / relax_time

    # RÃ©pulsion entre piÃ©tons
    for i in range(Nb):
        for j in range(i+1, Nb):
            d = positions[i] - positions[j]
            dist = np.linalg.norm(d)
            if dist > 1e-5:
                f = A * np.exp(-dist / B) * (d / dist)
                forces[i] += f
                forces[j] -= f

    # RÃ©pulsion avec les murs
    for i in range(Nb):
        y = positions[i, 1]
        forces[i, 1] += wall_repulsion / (y + 1e-3)
        forces[i, 1] -= wall_repulsion / (W - y + 1e-3)

    return forces

# --- Mise Ã  jour ---
frame_idx = 0  # compteur global

def update(frame):
    global positions, velocities, frame_idx

    f = social_forces(positions, velocities)
    velocities += f * dt
    positions += velocities * dt

    # Enregistrement des positions Ã  ce step
    if frame_idx < steps:
        # on garde la taille constante en remplissant avec NaN pour les piÃ©tons sortis
        All_positions[frame_idx, :positions.shape[0], :] = positions
        All_positions[frame_idx, positions.shape[0]:, :] = np.nan
        All_velocities[frame_idx, :positions.shape[0], :] = velocities
        All_velocities[frame_idx, positions.shape[0]:, :] = np.nan
        frame_idx += 1

    # Retirer les piÃ©tons sortis
    mask = positions[:, 0] < L
    positions = positions[mask]
    velocities = velocities[mask]

    scat.set_offsets(positions)
    return scat,

# --- Animation ---
fig, ax = plt.subplots(figsize=(12, 3))
scat = ax.scatter(positions[:, 0], positions[:, 1], c="blue")
ax.set_xlim(0, L)
ax.set_ylim(0, W)
ax.set_xlabel("x (m)")
ax.set_ylabel("y (m)")
ax.set_title("Simulation de piÃ©tons (animation)")

ani = FuncAnimation(fig, update, frames=steps, interval=50, blit=True, repeat=False)

plt.show()

# Ã€ la fin, All_positions contient toutes les positions sauvegardÃ©es
fig2, ax2 = plt.subplots(figsize=(12, 3))
ax2.set_xlim(0, L)
ax2.set_ylim(0, W)
ax2.set_xlabel("x (m)")
ax2.set_ylabel("y (m)")
ax2.set_title("Trajectoires des piÃ©tons")

# ðŸ”¹ Trace tous les piÃ©tons (ou un sous-Ã©chantillon si c'est trop dense)
subset = np.linspace(0, N-1, min(N, 20), dtype=int)  # max 20 piÃ©tons pour lisibilitÃ©
for i in subset:
    traj = All_positions[:, i, :]
    ax2.plot(traj[:, 0], traj[:, 1], alpha=0.3)

plt.show()


# ==== paramÃ¨tres du cadrillage ====
nx, ny = 100, 14    # nb de cases en x et y (ajuste si besoin)
normalize =False    # True: densitÃ© normalisÃ©e par nb de piÃ©tons actifs Ã  chaque frame

# ==== bords des cellules ====
x_edges = np.linspace(0, L, nx+1)
y_edges = np.linspace(0, W, ny+1)
x_cent = 0.5*(x_edges[:-1] + x_edges[1:])
y_cent = 0.5*(y_edges[:-1] + y_edges[1:])

steps = All_positions.shape[0]
D = np.zeros((steps, ny, nx), dtype=float)   # densitÃ© par frame

# ==== calcule la densitÃ© par frame ====
for t in range(steps):
    pos_t = All_positions[t]                 # (N, 2)
    mask = np.isfinite(pos_t[:,0]) & np.isfinite(pos_t[:,1])
    x = pos_t[mask, 0]
    y = pos_t[mask, 1]
    H, _, _ = np.histogram2d(y, x, bins=[y_edges, x_edges])  # (ny, nx)

    if normalize:
        H = H / max(1, mask.sum())          # normalisation par nb de piÃ©tons prÃ©sents
    D[t] = H


# ==== 2) animation frame par frame ====
fig, ax = plt.subplots(figsize=(12, 3))
quad = ax.pcolormesh(x_edges, y_edges, D[0], shading='auto')
cbar = plt.colorbar(quad, ax=ax, label=("densitÃ© normalisÃ©e" if normalize else "comptes"))
ax.set_xlabel("x (m)")
ax.set_ylabel("y (m)")

ax.set_xlim(0, L)
ax.set_ylim(0, W)
ax.set_title("DensitÃ© par pas de temps")

# Ã©chelle de couleur fixe pour Ã©viter le pompage (prend des percentiles robustes)
vmin = np.percentile(D, 5)
vmax = np.percentile(D, 95)
quad.set_clim(vmin, vmax)

def update(k):
    quad.set_array(D[k].ravel())  # pcolormesh attend un array aplati (ny*nx,)
    ax.set_title(f"DensitÃ© au pas t={k+1}/{steps}")
    return (quad,)

ani = FuncAnimation(fig, update, frames=steps, interval=60, blit=False, repeat=False)
plt.tight_layout()

plt.show()

#%% 
#############
############
## Neural network pour predire vx et vy en fonction de phi
###########
###########

# === Construction du dataset Ï† -> v ===

phi_list = []
vx_list = []
vy_list = []

for t in range(steps):

    pos_t = All_positions[t]       # (N, 2)
    vel_t = All_velocities[t]      # (N, 2)

    mask = np.isfinite(pos_t[:,0]) & np.isfinite(pos_t[:,1])
    pos_t = pos_t[mask]
    vel_t = vel_t[mask]

    # Pour chaque piÃ©ton, trouver son index de cellule
    x_idx = np.searchsorted(x_edges, pos_t[:,0], side='right') - 1
    y_idx = np.searchsorted(y_edges, pos_t[:,1], side='right') - 1

    # On ne garde que les piÃ©tons vraiment dans la grille
    valid = (x_idx >= 0) & (x_idx < nx) & (y_idx >= 0) & (y_idx < ny)
    x_idx = x_idx[valid]
    y_idx = y_idx[valid]
    vel_t = vel_t[valid]

    # Regroupement par cellule
    for i in range(len(x_idx)):
        ix, iy = x_idx[i], y_idx[i]

        phi = D[t, iy, ix]   # densitÃ© dans la cellule au frame t
        vx, vy = vel_t[i]    # vitesse du piÃ©ton i

        phi_list.append(phi)
        vx_list.append(vx)
        vy_list.append(vy)

phi_arr = np.array(phi_list, dtype=float)
vx_arr = np.array(vx_list, dtype=float)
vy_arr = np.array(vy_list, dtype=float)

print("Dataset crÃ©Ã© : ", phi_arr.shape, vx_arr.shape)

class PhiVeloDataset(Dataset):
    def __init__(self, phi, vx, vy):
        self.phi = torch.tensor(phi, dtype=torch.float32).unsqueeze(1)
        self.v = torch.tensor(np.stack([vx, vy], axis=1), dtype=torch.float32)

    def __len__(self):
        return len(self.phi)

    def __getitem__(self, idx):
        return self.phi[idx], self.v[idx]

dataset = PhiVeloDataset(phi_arr, vx_arr, vy_arr)
loader = DataLoader(dataset, batch_size=512, shuffle=True)

##### 
####
###CrÃ©ation du Neural Network
####
#####
    
class VphiNN2(nn.Module):
    def __init__(self, hidden=[64, 64, 64]):
        super().__init__()
        layers = []
        dims = [1] + hidden + [2]

        for a,b in zip(dims[:-2], dims[1:-1]):
            layers.append(nn.Linear(a,b))
            layers.append(nn.Tanh())
        layers.append(nn.Linear(dims[-2], dims[-1]))

        self.net = nn.Sequential(*layers)

    def forward(self, phi):
        return self.net(phi)
model = VphiNN2()
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
loss_fn = nn.MSELoss()

loss_history = []

for epoch in range(1000):
    running_loss = 0.0

    for phi_batch, v_batch in loader:
        optimizer.zero_grad()
        pred = model(phi_batch)
        loss = loss_fn(pred, v_batch)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

    loss_history.append(running_loss)

    if epoch % 200 == 0:
        print(f"Epoch {epoch} - Loss: {running_loss:.5f}")

########
# Plot v_x(phi) and v_y(phi)
########

phi_test = torch.linspace(0, phi_arr.max(), 200).unsqueeze(1)
v_pred = model(phi_test).detach().numpy()

plt.figure(figsize=(10,4))

plt.subplot(1,2,1)
plt.plot(phi_arr, vx_arr, 'k.', alpha=0.05, label="data vx")
plt.plot(phi_test, v_pred[:,0], 'r', label="NN vx")
plt.xlabel("Ï†")
plt.ylabel("v_x")
plt.legend()

plt.subplot(1,2,2)
plt.plot(phi_arr, vy_arr, 'k.', alpha=0.05, label="data vy")
plt.plot(phi_test, v_pred[:,1], 'r', label="NN vy")
plt.xlabel("Ï†")
plt.ylabel("v_y")
plt.legend()

plt.show()
